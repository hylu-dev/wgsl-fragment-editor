class t{constructor(t,e={}){this.selector=t,this.container=null,this.canvas=null,this.codeEditor=null,this.statusElement=null,this.wasmModule=null,this.isInitialized=!1,this.initialShader=e.initialShader||this.getDefaultShader(),this.init()}getDefaultShader(){return"// Fragment shader - write your complete @fragment function\n// The vertex shader and structs will be added automatically\n\n@fragment\nfn fs_main(in: VertexOutput) -> @location(0) vec4<f32> {\n    let uv = in.uv * 2.0 - 1.0;\n    var dist = sin(length(uv * 8.0 * PI) + u_time.t);\n    dist += sin(atan2(uv.y, uv.x) * 8.0 + u_time.t * 0.5);\n    let color = vec4<f32>(dist, dist, dist, 1.0);\n    return color;\n}"}getWasmModulePath(){const t=document.currentScript;if(t){const e=t.src;return`${e.substring(0,e.lastIndexOf("/"))}/wgpu_shader_canvas.js`}return"./wgpu_shader_canvas.js"}async init(){try{await this.createLayout(),await this.loadWasmModule(),this.setupEventListeners(),this.isInitialized=!0,console.log("ShaderCanvasUI initialized successfully")}catch(t){throw console.error("Failed to initialize ShaderCanvasUI:",t),t}}async createLayout(){if(this.container=document.querySelector(this.selector),!this.container)throw new Error(`Element with selector "${this.selector}" not found`);this.container.innerHTML=`\n            <div class="code-panel">\n                <div class="code-editor-container">\n                    <textarea id="shader-text" \n                              class="code-editor" \n                              placeholder="Paste your fragment shader code here...">${this.initialShader}</textarea>\n                </div>\n                <div class="canvas-panel">\n                    <canvas id="canvas" class="shader-canvas"></canvas>\n                    <div class="shader-status" id="shader-status"></div>\n                </div>\n            </div>\n        `,this.canvas=document.getElementById("canvas"),this.codeEditor=document.getElementById("shader-text"),this.statusElement=document.getElementById("shader-status")}async loadWasmModule(){try{const t=this.getWasmModulePath();this.wasmModule=await import(t);const{load_shader_from_url:e,load_shader_from_text:a,reload_shader:s,get_current_shader_text:n}=this.wasmModule,r=this.wasmModule.default;try{await r()}catch(t){}this.wasmFunctions={load_shader_from_text:a,reload_shader:s,get_current_shader_text:n},console.log("WASM module loaded successfully")}catch(t){throw console.error("Failed to load WASM module:",t),t}}setupEventListeners(){this.codeEditor.addEventListener("input",t=>{const e=t.target.value;this.loadShader(e)});const t=this.codeEditor.value;this.loadShader(t),this.statusElement.addEventListener("mouseenter",()=>{const t=this.statusElement.dataset.detailedError;t&&(this.statusElement.textContent=t)}),this.statusElement.addEventListener("mouseleave",()=>{this.statusElement.textContent="Shader Error"})}updateStatus(t,e=!1,a=""){this.statusElement.textContent=t,this.statusElement.className="shader-status",e?(this.statusElement.classList.add("show"),this.statusElement.dataset.detailedError=a||t):(this.statusElement.classList.remove("show"),this.statusElement.dataset.detailedError="")}wrapFragmentShader(t){return this.createCompleteShader(t)}createCompleteShader(t){return`// Vertex shader\n\nconst PI: f32 = 3.1415926535;\n\n// Time uniform - 16-byte aligned\nstruct TimeUniform {\n    t: f32,\n    _padding: f32,\n    _padding2: f32,\n    _padding3: f32,\n}\n\n@group(0) @binding(0)\nvar<uniform> camera: mat4x4<f32>;\n\n@group(0) @binding(1)\nvar<uniform> u_time: TimeUniform;\n\nstruct VertexInput {\n    @location(0) pos: vec3<f32>,\n    @location(1) color: vec3<f32>,\n};\n\nstruct VertexOutput {\n    @builtin(position) clip_position: vec4<f32>,\n    @location(0) uv: vec2<f32>,\n    @location(1) color: vec3<f32>,\n};\n\n@vertex\nfn vs_main(\n    model: VertexInput,\n) -> VertexOutput {\n    var out: VertexOutput;\n    out.color = model.color;\n    out.clip_position = vec4<f32>(model.pos, 1.0);\n    out.uv = vec2<f32>(model.pos.x * 0.5 + 0.5, model.pos.y * 0.5 + 0.5);\n    return out;\n}\n\n${t}`}loadShader(t){console.log("Attempting to load shader");try{const e=this.wrapFragmentShader(t);this.wasmFunctions.load_shader_from_text(e),this.updateStatus("Shader Error",!1)}catch(t){const e=t.message||t.toString()||"Unknown shader error";this.updateStatus("Shader Error",!0,e),console.warn("Shader compilation error:",t)}}reloadDefaultShader(){try{this.wasmFunctions.reload_shader(),this.updateStatus("✓ Default shader reloaded",!1),console.log("Default shader reloaded"),this.codeEditor.value=this.initialShader}catch(t){this.updateStatus(`✗ Reload failed: ${t.message||t}`,!0)}}getCanvas(){return this.canvas}getCodeEditor(){return this.codeEditor}getStatusElement(){return this.statusElement}setShaderCode(t){this.codeEditor.value=t,this.codeEditor.dispatchEvent(new Event("input"))}getShaderCode(){return this.codeEditor.value}setInitialShader(t){this.initialShader=t}destroy(){this.shaderLoadTimeout&&clearTimeout(this.shaderLoadTimeout),this.container&&this.container.parentNode&&this.container.parentNode.removeChild(this.container)}}"undefined"!=typeof module&&module.exports?module.exports=t:"undefined"!=typeof window&&(window.ShaderCanvas=t);export{t as default};
//# sourceMappingURL=wgpu-shader-canvas.min.js.map

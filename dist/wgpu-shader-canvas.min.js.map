{"version":3,"file":"wgpu-shader-canvas.min.js","sources":["../web/shader-canvas.js"],"sourcesContent":["/**\n * Simple Shader Canvas\n * Usage: \n *   new ShaderCanvas('#app-container')\n *   new ShaderCanvas('#app-container', { initialShader: 'your shader code here' })\n */\nclass ShaderCanvas {\n    constructor(selector, options = {}) {\n        this.selector = selector;\n        this.container = null;\n        this.canvas = null;\n        this.codeEditor = null;\n        this.statusElement = null;\n        this.wasmModule = null;\n        this.isInitialized = false;\n        \n        // Extract options\n        this.initialShader = options.initialShader || this.getDefaultShader();\n\n        this.init();\n    }\n\n    getDefaultShader() {\n        return `// Fragment shader - write your complete @fragment function\n// The vertex shader and structs will be added automatically\n\n@fragment\nfn fs_main(in: VertexOutput) -> @location(0) vec4<f32> {\n    let uv = in.uv * 2.0 - 1.0;\n    var dist = sin(length(uv * 8.0 * PI) + u_time.t);\n    dist += sin(atan2(uv.y, uv.x) * 8.0 + u_time.t * 0.5);\n    let color = vec4<f32>(dist, dist, dist, 1.0);\n    return color;\n}`;\n    }\n\n    getWasmModulePath() {\n        // Try to determine the correct path for the WASM module\n        // This handles both local development and GitHub Pages deployment scenarios\n        \n        // First, try to get the current script's base URL\n        const currentScript = document.currentScript;\n        if (currentScript) {\n            const scriptSrc = currentScript.src;\n            const baseUrl = scriptSrc.substring(0, scriptSrc.lastIndexOf('/'));\n            return `${baseUrl}/wgpu_shader_canvas.js`;\n        }\n        \n        // Fallback: use relative path (should work in most cases)\n        return './wgpu_shader_canvas.js';\n    }\n\n    async init() {\n        try {\n            await this.createLayout();\n            await this.loadWasmModule();\n            this.setupEventListeners();\n            this.isInitialized = true;\n            console.log('ShaderCanvasUI initialized successfully');\n        } catch (error) {\n            console.error('Failed to initialize ShaderCanvasUI:', error);\n            throw error;\n        }\n    }\n\n    async createLayout() {\n        // Get the target container\n        this.container = document.querySelector(this.selector);\n        if (!this.container) {\n            throw new Error(`Element with selector \"${this.selector}\" not found`);\n        }\n\n        // Clear existing content and add the shader canvas layout\n        this.container.innerHTML = `\n            <div class=\"code-panel\">\n                <div class=\"code-editor-container\">\n                    <textarea id=\"shader-text\" \n                              class=\"code-editor\" \n                              placeholder=\"Paste your fragment shader code here...\">${this.initialShader}</textarea>\n                </div>\n                <div class=\"canvas-panel\">\n                    <canvas id=\"canvas\" class=\"shader-canvas\"></canvas>\n                    <div class=\"shader-status\" id=\"shader-status\"></div>\n                </div>\n            </div>\n        `;\n\n        // Get references to elements\n        this.canvas = document.getElementById('canvas');\n        this.codeEditor = document.getElementById('shader-text');\n        this.statusElement = document.getElementById('shader-status');\n    }\n\n    async loadWasmModule() {\n        try {\n            // Try to determine the correct path for the WASM module\n            const wasmPath = this.getWasmModulePath();\n            this.wasmModule = await import(wasmPath);\n            const { load_shader_from_url, load_shader_from_text, reload_shader, get_current_shader_text } = this.wasmModule;\n\n            // Initialize WASM\n            const init = this.wasmModule.default;\n            try {\n                await init();\n            } catch (wasmError) {\n                // WASM initialization might throw \"exceptions for control flow\" - this is normal\n            }\n\n            // Store the functions for later use\n            this.wasmFunctions = {\n                load_shader_from_text,\n                reload_shader,\n                get_current_shader_text\n            };\n\n            console.log('WASM module loaded successfully');\n        } catch (error) {\n            console.error('Failed to load WASM module:', error);\n            throw error;\n        }\n    }\n\n    setupEventListeners() {\n        // Auto-load shader on text change\n        this.codeEditor.addEventListener('input', (e) => {\n            const text = e.target.value;\n            this.loadShader(text);\n        });\n\n        // Load initial shader immediately\n        const initialShader = this.codeEditor.value;\n        this.loadShader(initialShader);\n\n        // Add hover behavior for error status\n        this.statusElement.addEventListener('mouseenter', () => {\n            const detailedError = this.statusElement.dataset.detailedError;\n            if (detailedError) {\n                this.statusElement.textContent = detailedError;\n            }\n        });\n\n        this.statusElement.addEventListener('mouseleave', () => {\n            // Reset to original message\n            this.statusElement.textContent = 'Shader Error';\n        });\n    }\n\n    updateStatus(message, isError = false, detailedError = '') {\n        this.statusElement.textContent = message;\n        this.statusElement.className = 'shader-status';\n        \n        if (isError) {\n            this.statusElement.classList.add('show');\n            // Store the detailed error for hover display\n            this.statusElement.dataset.detailedError = detailedError || message;\n        } else {\n            // Hide status for success (no error)\n            this.statusElement.classList.remove('show');\n            this.statusElement.dataset.detailedError = '';\n        }\n    }\n\n    wrapFragmentShader(fragmentCode) {\n        // Always wrap the fragment code - assume user only writes fragment shader\n        return this.createCompleteShader(fragmentCode);\n    }\n\n    createCompleteShader(fragmentCode) {\n        const vertexShader = `// Vertex shader\n\nconst PI: f32 = 3.1415926535;\n\n// Time uniform - 16-byte aligned\nstruct TimeUniform {\n    t: f32,\n    _padding: f32,\n    _padding2: f32,\n    _padding3: f32,\n}\n\n@group(0) @binding(0)\nvar<uniform> camera: mat4x4<f32>;\n\n@group(0) @binding(1)\nvar<uniform> u_time: TimeUniform;\n\nstruct VertexInput {\n    @location(0) pos: vec3<f32>,\n    @location(1) color: vec3<f32>,\n};\n\nstruct VertexOutput {\n    @builtin(position) clip_position: vec4<f32>,\n    @location(0) uv: vec2<f32>,\n    @location(1) color: vec3<f32>,\n};\n\n@vertex\nfn vs_main(\n    model: VertexInput,\n) -> VertexOutput {\n    var out: VertexOutput;\n    out.color = model.color;\n    out.clip_position = vec4<f32>(model.pos, 1.0);\n    out.uv = vec2<f32>(model.pos.x * 0.5 + 0.5, model.pos.y * 0.5 + 0.5);\n    return out;\n}\n\n${fragmentCode}`;\n\n        return vertexShader;\n    }\n\n\n    loadShader(text) {\n        console.log(\"Attempting to load shader\");\n        try {\n            // Wrap the fragment shader code if needed\n            const completeShader = this.wrapFragmentShader(text);\n            \n            // Attempt to load the shader - Rust throws on error, returns undefined on success\n            this.wasmFunctions.load_shader_from_text(completeShader);\n            \n            // If we get here, the shader loaded successfully\n            this.updateStatus('Shader Error', false); // Hide status on success\n            //console.log(\"Shader loaded successfully\");\n        } catch (error) {\n            // Shader compilation failed - show the error message with details\n            const errorMessage = error.message || error.toString() || 'Unknown shader error';\n            this.updateStatus('Shader Error', true, errorMessage);\n            console.warn(\"Shader compilation error:\", error);\n        }\n    }\n\n    reloadDefaultShader() {\n        try {\n            this.wasmFunctions.reload_shader();\n            \n            // If we get here, the reload was successful\n            this.updateStatus('✓ Default shader reloaded', false);\n            console.log(\"Default shader reloaded\");\n            \n            // Reset to initial fragment shader code\n            this.codeEditor.value = this.initialShader;\n        } catch (error) {\n            // Reload failed - show the error message\n            this.updateStatus(`✗ Reload failed: ${error.message || error}`, true);\n            //console.error(\"Failed to reload shader:\", error);\n        }\n    }\n\n\n    // Public API methods\n    getCanvas() {\n        return this.canvas;\n    }\n\n    getCodeEditor() {\n        return this.codeEditor;\n    }\n\n    getStatusElement() {\n        return this.statusElement;\n    }\n\n    setShaderCode(code) {\n        this.codeEditor.value = code;\n        this.codeEditor.dispatchEvent(new Event('input'));\n    }\n\n    getShaderCode() {\n        return this.codeEditor.value;\n    }\n\n    setInitialShader(shaderCode) {\n        this.initialShader = shaderCode;\n    }\n\n    destroy() {\n        if (this.shaderLoadTimeout) {\n            clearTimeout(this.shaderLoadTimeout);\n        }\n        if (this.container && this.container.parentNode) {\n            this.container.parentNode.removeChild(this.container);\n        }\n    }\n}\n\n// Export for use in other modules\nif (typeof module !== 'undefined' && module.exports) {\n    module.exports = ShaderCanvas;\n} else if (typeof window !== 'undefined') {\n    window.ShaderCanvas = ShaderCanvas;\n}\n\n// ES module export\nexport default ShaderCanvas;\n"],"names":["ShaderCanvas","constructor","selector","options","this","container","canvas","codeEditor","statusElement","wasmModule","isInitialized","initialShader","getDefaultShader","init","getWasmModulePath","currentScript","document","scriptSrc","src","substring","lastIndexOf","createLayout","loadWasmModule","setupEventListeners","console","log","error","querySelector","Error","innerHTML","getElementById","wasmPath","import","load_shader_from_url","load_shader_from_text","reload_shader","get_current_shader_text","default","wasmError","wasmFunctions","addEventListener","e","text","target","value","loadShader","detailedError","dataset","textContent","updateStatus","message","isError","className","classList","add","remove","wrapFragmentShader","fragmentCode","createCompleteShader","completeShader","errorMessage","toString","warn","reloadDefaultShader","getCanvas","getCodeEditor","getStatusElement","setShaderCode","code","dispatchEvent","Event","getShaderCode","setInitialShader","shaderCode","destroy","shaderLoadTimeout","clearTimeout","parentNode","removeChild","module","exports","window"],"mappings":"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"}